<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇奇怪怪的博客</title>
  
  
  <link href="http://oneis2much.github.io/rss.xml" rel="self"/>
  
  <link href="http://oneis2much.github.io/"/>
  <updated>2025-08-12T09:01:40.872Z</updated>
  <id>http://oneis2much.github.io/</id>
  
  <author>
    <name>oneis2much</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>异或小知识</title>
    <link href="http://oneis2much.github.io/2025/08/10/%E5%BC%82%E6%88%96%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://oneis2much.github.io/2025/08/10/%E5%BC%82%E6%88%96%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2025-08-10T10:14:04.018Z</published>
    <updated>2025-08-12T09:01:40.872Z</updated>
    
    <content type="html"><![CDATA[<p class='item-img' data-src='/img/header/f7d6162a-b855-4727-a443-aae7c2194657.png'><img src="/img/header/f7d6162a-b855-4727-a443-aae7c2194657.png" alt="alt text"></p><p>这是一篇关于异或的一些知识的合集。</p><span id="more"></span><p>阅读提示：本人没有良好的学术素养，因此在书写本文时，并没有注意用词的严谨性，文章为了易于理解，所举的例子也较为通俗，阅读时若不当的用词引起了您的红温，请原谅我。</p><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><blockquote><p>这个部分包括对异或运算的规则和部分性质的介绍，若您对异或已经有了一部分的了解，可以直接跳过这个部分。</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>异或</code>是一种运算，一般作用于两个整数之间，更具体来说，作用于两个二进制整数之间。我们使用 <script type="math/tex">\oplus</script> 符号来表示<code>异或</code>运算。</p><p><code>异或</code>的运算规则为：二数相同为<code>0</code>，二数不同为<code>1</code>。如果难以理解的话，可以直接看下面的这个表格：</p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center"><script type="math/tex">0 \oplus 0</script></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><script type="math/tex">0 \oplus 1</script></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><script type="math/tex">1 \oplus 0</script></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><script type="math/tex">1 \oplus 1</script></td><td style="text-align:center">0</td></tr></tbody></table></div><blockquote><p>如果我们忽略进位信息，可以发现<code>异或</code>的运算结果和<code>二进制下的加法</code>的运算结果是相同的。因此也可以把<code>异或</code>理解为<strong>不进位的加法</strong>。</p></blockquote><p>对于多位的数，异或运算应逐位异或，如：<script type="math/tex">001 \oplus 100 = 101</script></p><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>异或符合以下的运算法则：</p><ul><li>交换律：<script type="math/tex">a \oplus b = b \oplus a</script></li><li>结合律：<script type="math/tex">a \oplus b \oplus c = a \oplus (b \oplus c)</script></li><li>存在单位元 0： <script type="math/tex">a \oplus 0 = a</script></li><li>存在逆元且任何元素的逆元都是自己： <script type="math/tex">a \oplus a = 0</script></li></ul><h3 id="引申性质"><a href="#引申性质" class="headerlink" title="引申性质"></a>引申性质</h3><div class="admonition expand-box adm-note open"        style="--ex-color:green">        <div class="ex-header">            <i class='i-status'></i>            <i class='i-adm i-note'></i>            <span class="ex-title">异或的存储状态性质</span>        </div>        <div class="ex-content"><p><code>异或</code>是唯二的存在逆运算的位运算（另一个是<code>非</code>），对于一个<code>有限位</code>的存储单元来说，对其作<code>与</code>、<code>或</code>、<code>左移</code>、<code>右移</code>都可能会导致其数据无法通过逆运算还原。因此我们可以认为异或拥有存储状态的性质，也就是说，对于一个存储了<script type="math/tex">a \oplus b</script>的单元来说，它会隐含的存储 <script type="math/tex">a</script> 和 <script type="math/tex">b</script> ，我们一定可以通过异或运算将其还原成 <script type="math/tex">a</script> 或是 <script type="math/tex">b</script> 。</p></div>        </div><ul><li><script type="math/tex">a \oplus b \oplus b = a</script> 证明如下：</li></ul><script type="math/tex; mode=display">a \oplus b \oplus b = a \oplus (b \oplus b) = a \oplus 0 = a</script><ul><li><script type="math/tex">a \oplus b \oplus a = b</script> 证明如下：</li></ul><script type="math/tex; mode=display">a \oplus b \oplus a = b \oplus a \oplus a = b</script><ul><li>以上两条性质可以推广到<script type="math/tex">n</script>位的情况。如：<script type="math/tex">a \oplus b \oplus c \oplus c \oplus b = a</script>。实用意义可以参考<a href="#交换两个数">交换数字</a>。</li></ul><h2 id="异或的实用意义"><a href="#异或的实用意义" class="headerlink" title="异或的实用意义"></a>异或的实用意义</h2><h3 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h3><blockquote><p>在多数编程语言中，异或使用<code>^</code>运算符表示，这一节的代码为伪代码，您可以认为是<code>C语言</code>/<code>C++</code>/<code>Java</code>等语言。</p></blockquote><p>一般地，想要交换两个数，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = tmep;<br>&#125;<br></code></pre></td></tr></table></figure><p>在知道了异或可以存储状态的特性后，我们也可以这样交换两个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>&#123;<br>    a ^= b; <span class="hljs-comment">// a: a ^ b</span><br>    b ^= a; <span class="hljs-comment">// b: b ^ (a ^ b) = a</span><br>    a ^= b; <span class="hljs-comment">// a: (a ^ b) ^ a = b</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀异或"><a href="#前缀异或" class="headerlink" title="前缀异或"></a>前缀异或</h3><p>问题描述：<br>输入一个长度为<code>n</code>的整数序列。接下来再输入<code>m</code>个询问，每个询问输入一对<code>l</code>,<code>r</code>。<br>对于每次询问，输出原序列中从第<code>l</code>个数到第<code>r</code>个数的异或结果。</p><p>暴力的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-comment">// 为了方便理解，nums数组的下标为1到n，而不是0到n-1</span><br>    <span class="hljs-keyword">while</span> (m -- ) &#123;<br>        <span class="hljs-type">int</span> l, r, result = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; l &gt;&gt; r;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++ ) &#123;<br>            result ^= nums[i];<br>        &#125;<br><br>        cout &lt;&lt; result &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑最坏的情况下，每次询问的长度最大为<script type="math/tex">n</script>，因此运算的代码最多会被执行<script type="math/tex">n \cdot m</script>次。</p><p>让我们联想一下<code>前缀和</code>，如果您不了解<code>前缀和</code>，可以快速地过一下下面的介绍。</p><blockquote><p>若要求给定的数列<script type="math/tex">a_n</script>中，<script type="math/tex">a_l + a_{l+1} + \dots + a_{r-1} + a_{r}</script>的值为多少，我们可以定义<script type="math/tex">S_n</script>为<script type="math/tex">\sum\limits_{i=1}^{n}a_n</script>，就会有</p><script type="math/tex; mode=display">a_l + a_{l+1} + a_{l+2} + \dots + a_{r-2} + a_{r-1} + a_{r} = S_r - S_{l - 1} \qquad l \ne 1或a_0=0</script><p>证明？自己证一下吧，总而言之，我们把<script type="math/tex">S_n</script>称为数列<script type="math/tex">a_n</script>的<code>前缀和</code>。</p><div class="admonition expand-box adm-note fold"        style="--ex-color:green">        <div class="ex-header">            <i class='i-status'></i>            <i class='i-adm i-note'></i>            <span class="ex-title">简短的证明思路</span>        </div>        <div class="ex-content"><p>因为加法满足交换律和结合律，我们可以通过移项的方式，将部分元素消除。</p></div>        </div></blockquote><p>与<code>前缀和</code>类似的是，异或运算也满足交换律和结合律，并且异或就是其本身的逆运算。因此我们定义一个数列<script type="math/tex">S_n</script>为原序列的前<script type="math/tex">n</script>个数相异或的结果，我们把这样的数列称为<code>前缀异或</code>，那么原序列中从第<code>l</code>个数到第<code>r</code>个数的异或结果便可以表示为<script type="math/tex">S_r \oplus S_{l-1}</script>，因此我们可以这样优化代码：</p><div class="admonition expand-box adm-note fold"        style="--ex-color:green">        <div class="ex-header">            <i class='i-status'></i>            <i class='i-adm i-note'></i>            <span class="ex-title">简短的证明思路</span>        </div>        <div class="ex-content"><p>通过移项的方式，将部分元素消除。</p></div>        </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-comment">// 为了方便理解，nums数组的下标为1到n，而不是0到n-1</span><br><br>    nums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        nums[i] ^= nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- ) &#123;<br>        <span class="hljs-type">int</span> l, r；<br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; (nums[l - <span class="hljs-number">1</span>] ^ nums[r]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑最坏的情况下，每次询问的长度最大为<script type="math/tex">n</script>，因此运算的代码最多会被执行<script type="math/tex">n + m</script>次。<br>当<script type="math/tex">n</script>和<script type="math/tex">m</script>的数量较大时，我们可以将二者都看作<script type="math/tex">n</script>，因此第一种写法的复杂度约为<script type="math/tex">n^2</script>，而第二种写法的复杂度约为<script type="math/tex">2n</script>，因此我们将二次级别的复杂度优化到了一次级别的复杂度。</p><h3 id="异或加密"><a href="#异或加密" class="headerlink" title="异或加密"></a>异或加密</h3><blockquote><p>在计算机中，数据都是以二进制的 01 表示的，某些文件涉及到隐私安全，需要加密保护，异或的某些性质正好可以用来对加密/解密。</p></blockquote><p>让我们假设某个文件中的某个字节的数据是这样的：<code>10100011</code>，我们设定一个密码，比如<code>1010</code>。</p><p>现在我们该如何对这个文件的安全进行保护呢？我们可以想到建立一个密码表(如下)，当用户输入一个密码后，软件从密码表中查找，如果密码正确，则允许用户正常地访问文件。</p><div class="table-container"><table><thead><tr><th style="text-align:center">文件名</th><th style="text-align:center">密码</th></tr></thead><tbody><tr><td style="text-align:center">test.txt</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">hello.mp3</td><td style="text-align:center">666</td></tr></tbody></table></div><p>问题在于，如果黑客入侵了系统，那么黑客就可以直接找到文件的密码，此外，黑客还可以得知其他文件的密码。因此这样的系统安全性是非常低的。</p><p>所以我们不得不思考是否有其他的更安全的方案。我们注意到，异或满足<script type="math/tex">a \oplus b \oplus b = a</script>的性质，因此我们可以让文件逐位地与密码相异或，这样就实现了对文件数据的加密。例如某个文件中的某个字节的数据是这样的：<code>10100011</code>，我们设定一个密码，比如<code>1010</code>，密码先与低位的<code>0011</code>进行异或运算，得到<code>1001</code>，再与高位的<code>1010</code>进行异或运算，得到<code>0000</code>，因此最后得到的加密后数据为<code>00001001</code>。对文件的所有字节的数据采用同样的运算后，整个文件的数据便成了加密后的密文。</p><p>当用户想打开这个文件时，用户首先输入密码，软件所做的操作是，将文件的二进制数据依次与密码进行异或运算，<code>00001001</code>在运算后便可以得到原始的<code>10100011</code>。这样做的好处在于：</p><ul><li>文件实现了真正意义上的加密，他人通过分享的方式取得了文件，文件依然是加密的状态。</li><li>文件的密码没有存储在操作系统中，减少了被黑客入侵的风险。</li><li>输入错误的密码会导致文件数据变成错误的数据，我们可以设立某个字段为关键字，用来校验密码是否正确，如某个字段加密前为<code>&#39;abc&#39;</code>，如果用户输入了错误的密码，导致这个字段变成了<code>&#39;1a8&#39;</code>，软件检测到校验位的字段内容不是<code>&#39;abc&#39;</code>，就可以得知用户输入的密码有误。</li><li>基于这样的方案，我们还可以设计出二级加密、三级加密等。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/header/f7d6162a-b855-4727-a443-aae7c2194657.png&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是一篇关于异或的一些知识的合集。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="http://oneis2much.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="异或" scheme="http://oneis2much.github.io/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
</feed>
